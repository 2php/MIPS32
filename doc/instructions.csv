Instruction,Assembly,Format Type,Function Type,Function Definition,Encoding:[31-26],[25-21],[20-16],[15-11],[10-6],[5-0],Stages:Fetch,Decode,Excute,Memory,Write Back,Notes
common,,,,,,,,,,,"PC<=NPC
IR=Men[PC]
NPC<=PC+4","OP=IR[25-21]
бн","alu_a = reg1
alu_b = reg2
except:",,,
sll,"SLL rd, rt, sa",R,shift,R[rd]<=R[rt]<<sa,000000,00000,rt,rd,sa,000000,,reg2=R[rt],alu_a = zero_extend(sa),N/A,R[rd]=alu_r,"SLL r0,r0,0, expressed as NOP"
srl,"SRL rd, rt, sa",R,shift,R[rd]<=R[rt]>>sa(logical),000000,00000,rt,rd,sa,000010,,reg2=R[rt],alu_a = zero_extend(sa),N/A,R[rd]=alu_r,
sra,"SRA rd, rt, sa",R,shift,R[rd]<=R[rt]>>sa(arithmetic),000000,00000,rt,rd,sa,000011,,reg2=R[rt],alu_a = zero_extend(sa),N/A,R[rd]=alu_r,
sllv,"SLLV rd, rt, rs",R,shift,R[rd]<=R[rt]<<R[rs][4..0],000000,rs,rt,rd,00000,000100,,reg1=R[rs] reg2=R[rt],,N/A,R[rd]=alu_r,The bit-shift amount is specified by the low-order 5 bits of R[rs]
srlv,"SRLV rd, rt, rs",R,shift,R[rd]<=R[rt]>>R[rs][4..0](logical),000000,rs,rt,rd,00000,000110,,reg1=R[rs] reg2=R[rt],,N/A,R[rd]=alu_r,The bit-shift amount is specified by the low-order 6 bits of R[rs]
srav,"SRAV rd, rt, rs",R,shift,R[rd]<=R[rt]>>R[rs][4..0](arithmetic),000000,rs,rt,rd,00000,000111,,reg1=R[rs] reg2=R[rt],,N/A,R[rd]=alu_r,The bit-shift amount is specified by the low-order 7 bits of R[rs]
jr,JR rs ,R,jump,PC<=R[rs],000000,rs,00000,00000,00000,001000,,reg1=R[rs] NPC<=reg1,N/A,N/A,N/A,"If either of the two least-significant bits are not zero, an Address Error exception occurs when the brach target is subsqeuently fetched as an instruction.If either of the two least-significant bits are not zero, an Address Error exception occurs when the brach target is subsqeuently fetched as an instruction."
jalr,"JALR rd, rs; JALR rs (rd=31 implied)",R,jump,R[rd]<=PC+8;PC<=R[rs],000000,rs,00000,rd,00000,001001,,reg1=R[rs] NPC<=reg1,N/A,N/A,R[rd]=PC+8,"Register specifiers rs and rd must not be equal. If either of the two least-significant bits are not zero, an Address Error exception occurs when the brach target is subsqeuently fetched as an instruction."
addu,"addu rd, rs, rt",R,arithmetic,R[rd]<=R[rs] + R[rt],000000,rs,rt,rd,00000,100001,,reg1=R[rs] reg2=R[rt],,N/A,R[rd]=alu_r,
subu,"subu rd, rs, rt",R,arithmetic,R[rd]<=R[rs] - R[rt],000000,rs,rt,rd,00000,100011,,reg1=R[rs] reg2=R[rt],,N/A,R[rd]=alu_r,
and,"and rd, rs, rt",R,logical,R[rd]<=R[rs] and R[rt],000000,rs,rt,rd,00000,100100,,reg1=R[rs] reg2=R[rt],,N/A,R[rd]=alu_r,
or,"or rd, rs, rt",R,logical,R[rd]<=R[rs] or R[rt],000000,rs,rt,rd,00000,100101,,reg1=R[rs] reg2=R[rt],,N/A,R[rd]=alu_r,
xor,"xor rd, rs, rt",R,logical,R[rd]<=R[rs] xor R[rt],000000,rs,rt,rd,00000,100110,,reg1=R[rs] reg2=R[rt],,N/A,R[rd]=alu_r,
nor,"nor rd, rs, rt",R,logical,R[rd]<=R[rs] nor R[rt],000000,rs,rt,rd,00000,100111,,reg1=R[rs] reg2=R[rt],,N/A,R[rd]=alu_r,
slt,"SLT rd, rs, rt",R,conditional,R[rd]<=(R[rs]<R[rt])(compare as signed integers),000000,rs,rt,rd,00000,101010,,reg1=R[rs] reg2=R[rt],,N/A,R[rd]=alu_r,
sltu,"SLTU rd, rs, rt",R,conditional,R[rd]<=(R[rs]<R[rt])(compare as unsigned integers),000000,rs,rt,rd,00000,101011,,reg1=R[rs] reg2=R[rt],,N/A,R[rd]=alu_r,
bltz,"BLTZ rs, offset",I,branch,if R[rs]<0 then PC<=PC+4+sign_extend(offset<<2),000001,rs,00000,offset,,,,reg1=R[rs] calc offset,alu_b = 0 NPC<=,N/A,N/A,
bgez,"BGEZ rs, offset",I,branch,if R[rs]=0 then PC<=PC+4+sign_extend(offset<<2),000001,rs,00001,offset,,,,reg1=R[rs] calc offset,alu_b = 0 NPC<=,N/A,N/A,
j,J target,J,jump,PC<=(PC+4)[31-28]&(instr_index<<2),000010,instr_index,,,,,NPC<=,N/A,N/A,N/A,N/A,
jal,JAL addr,J,jump,R[31]<=PC+8;PC<=(PC+4)[31-28]&(instr_index<<2),000011,instr_index,,,,,NPC<=,N/A,N/A,N/A,R[31]=PC+8,
beq,"BEQ rs, rt, offset",I,branch,if R[rs]==R[rt] then PC<=PC+4+sign_extend(offset<<2),000100,rs,rt,offset,,,,reg1=R[rs] reg2=R[rt],NPC<=,N/A,N/A,
bne,"BNE rs, rt, offset",I,branch,if R[rs]!=R[rt] then PC<=PC+4+sign_extend(offset<<2),000101,rs,rt,offset,,,,reg1=R[rs] reg2=R[rt],NPC<=,N/A,N/A,
blez,"BLEZ rs, offset",I,branch,if R[rs]<=0 then PC<=PC+4+sign_extend(offset<<2),000110,rs,00000,offset,,,,reg1=R[rs],NPC<=,N/A,N/A,
bgtz,"BGTZ rs, offset",I,branch,if R[rs]>0 then PC<=PC+4+sign_extend(offset<<2),000111,rs,00000,offset,,,,reg1=R[rs],NPC<=,N/A,N/A,
addiu,"ADDIU rt, rs, immediate",I,arithmetic,R[rt]<=R[rs] + sign_extend(immediate),001001,rs,rt,immediate,,,,reg1=R[rs],alu_b = sign_extend(imm),N/A,R[rt]=alu_r,
slti,"SLTI rt, rs, immediate",I,conditional,R[rt]<=(R[rs]<sign_extend(immediate))(compare as signed integers),001010,rs,rt,immediate,,,,reg1=R[rs],alu_b = sign_extend(imm),N/A,R[rt]=alu_r,
sltiu,"SLTIU rt, rs, immediate",I,conditional,R[rt]<=(R[rs]<sign_extend(immediate))(compare as unsigned integers),001011,rs,rt,immediate,,,,reg1=R[rs],alu_b = sign_extend(imm),N/A,R[rt]=alu_r,
andi,"ANDI rt, rs, immediate",I,logical,R[rt]<=R[rs] and zero_extend(immediate),001100,rs,rt,immediate,,,,reg1=R[rs],alu_b = zero_extend(imm),N/A,R[rt]=alu_r,
ori,"ORI rt, rs, immediate",I,logical,R[rt]<=R[rs] or zero_extend(immediate),001101,rs,rt,immediate,,,,reg1=R[rs],alu_b = zero_extend(imm),N/A,R[rt]=alu_r,
xori,"XORI rt, rs, immediate",I,logical,R[rt]<=R[rs] xori zero_extend(immediate),001110,rs,rt,immediate,,,,reg1=R[rs],alu_b = zero_extend(imm),N/A,R[rt]=alu_r,
lui,"LUI rt, immediate",I,arithmetic,R[rt]<=(immediate<<16),001111,00000,rt,immediate,,,,N/A,alu_a = 16,N/A,R[rt]=alu_r,
lb,"LB rt, offset(base)",I,transfer,R[rt]<=sign_extend(mem8[R[base]+sign_extend(offset)]),100000,base,rt,offset,,,,reg1=R[base],alu_b = sign_extend(offset),read_mem,R[rt]=mem_out,Address Error and more.
lw,"LW rt, offset(base)",I,transfer,R[rt]<=mem[R[base]+sign_extend(offset)],100011,base,rt,offset,,,,reg1=R[base],alu_b = sign_extend(offset),read_mem,R[rt]=mem_out,Address Error and more.
lbu,"SW rt, offset(base)",I,transfer,R[rt]<=zero_extend(mem8[R[base]+sign_extend(offset)]),100100,base,rt,offset,,,,reg1=R[base],alu_b = sign_extend(offset),read_mem,R[rt]=mem_out,Address Error and more.
sb,"LBU rt, offset(base)",I,transfer,mem8[R[base]+sign_extend(offset)] <= R[rt],101000,base,rt,offset,,,,reg1=R[base],alu_b = sign_extend(offset),write_mem,N/A,Address Error and more.
sw,"SB rt, offset(base)",I,transfer,mem[R[base]+sign_extend(offset)]<=R[rt],101011,base,rt,offset,,,,reg1=R[base],alu_b = sign_extend(offset),write_mem,N/A,Address Error and more.
